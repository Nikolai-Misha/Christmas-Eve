<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C√¢y th√¥ng Noel c·ªßa Chi</title>
    <link rel="icon" href="images/snow-flakes.ico" type="image/x-icon">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Borel&family=Shantell+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Borel', serif; user-select: none;}
        
        /* --- 1. M√ÄN H√åNH CH·ªú (LOADER) --- */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 3000;
            transition: opacity 1s ease-out;
        }
        .spinner {
            width: 60px; height: 60px; border: 2px solid rgba(212,175,55,0.1);
            border-radius: 50%; border-top-color: #D4AF37;
            animation: spin 1s infinite linear;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #loader-text { margin-top: 15px; color: #D4AF37; letter-spacing: 3px; font-size: 24px; }

        /* --- 2. H·ªòP H∆Ø·ªöNG D·∫™N (INTRO BOX) --- */
        #intro-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); /* N·ªÅn t·ªëi l√†m n·ªïi b·∫≠t h·ªôp */
            backdrop-filter: blur(8px);
            display: flex; align-items: center; justify-content: center;
            z-index: 2500; /* N·∫±m d∆∞·ªõi Loader nh∆∞ng tr√™n m·ªçi th·ª© kh√°c */
            transition: opacity 0.8s ease-out, visibility 0.8s;
        }
        #intro-box {
            width: 90%; max-width: 500px;
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid #D4AF37;
            border-radius: 25px; /* Bo g√≥c tr√≤n nh∆∞ y√™u c·∫ßu */
            padding: 40px 50px;
            text-align: center;
            box-shadow: 0 0 50px rgba(212, 175, 55, 0.3);
            color: #FFD700;
        }
        #intro-box h2 {
            margin-top: 0; font-size: 24px; letter-spacing: 2px; text-transform: uppercase;
            border-bottom: 1px dashed #555; padding-bottom: 15px; margin-bottom: 20px;
        }
        .guide-item {
            font-family: 'Borel', monospace; font-size: 22px; margin: 12px 0;
            display: flex; align-items: center; justify-content: center; gap: 10px;
            color: #FFF8DC;
        }
        .icon { font-size: 20px; }
        #start-btn {
            background: #D4AF37; color: #000; border: none;
            padding: 12px 40px; border-radius: 25px;
            font-family: 'Borel', serif; font-weight: bold; font-size: 16px;
            cursor: pointer; margin-top: 25px; transition: 0.3s;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.4);
        }
        #start-btn:hover { background: #FFF; box-shadow: 0 0 30px #FFF; transform: scale(1.05); }

        /* --- 3. TI√äU ƒê·ªÄ (G√ìC TR√ÅI) --- */
        #main-title {
            position: absolute; top: 30px; left: 40px; /* D·ªùi sang tr√°i */
            text-align: left;
            color: #FFD700; font-size: 28px; letter-spacing: 2px; opacity: 0.9; 
            text-transform: none; 
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.8), 0 0 30px rgba(255, 165, 0, 0.6);
            pointer-events: none; transition: opacity 0.5s;
            z-index: 5;
            max-width: calc(100vw - 80px);
            white-space: normal;
            word-wrap: break-word;
        }
        
        /* --- 4. CAMERA CONTAINER --- */
        #cam-container {
            position: absolute; bottom: 20px; left: 20px; width: 220px; height: 165px;
            border-radius: 12px; overflow: hidden; 
            border: 2px solid #D4AF37; 
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.5); 
            transform: scaleX(-1); 
            z-index: 10;
        }
        #cam-preview { 
            width: 100%; height: 100%; object-fit: cover; 
            filter: brightness(1.25) saturate(1.3) contrast(1.05) sepia(0.15) blur(0.8px);
        }
        #hand-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 12; pointer-events: none;
        }
        #cam-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.1) 20%, rgba(60, 40, 0, 0.3) 80%, rgba(0,0,0,0.8) 100%);
            box-shadow: inset 0 0 20px rgba(255, 215, 0, 0.3);
            pointer-events: none; z-index: 11; mix-blend-mode: overlay;
        }
        
        /* --- 5. Debug nh·ªè g√≥c d∆∞·ªõi (nh·∫Øc l·∫°i n·∫øu qu√™n) --- */
        #gesture-debug {
            position: absolute; bottom: 200px; left: 20px;
            color: #FFD700; font-family: 'Borel', monospace; font-size: 22px;
            text-shadow: 0 0 2px #000; pointer-events: none;
            line-height: 1.6; background: rgba(0,0,0,0.6);
            padding: 10px; border-radius: 8px; border-left: 2px solid #D4AF37;
        }

/* Tablet & Mobile l·ªõn (‚â§768px) */
@media (max-width: 768px) {body{padding:15px;}#main-title{font-size:2.8rem;line-height:1.2;}#gesture-debug{font-size:1.3rem;}#cam-container{width:180px;height:135px;bottom:15px;left:15px;}#intro-box{padding:30px 40px;}#intro-box h2{font-size:2.2rem;}.guide-item{font-size:1.8rem;}#start-btn{padding:10px 30px;font-size:1.4rem;}}

/* Mobile nh·ªè (‚â§480px) */
@media (max-width: 480px) {body{padding:10px;}#main-title{font-size:2.2rem;}#gesture-debug{font-size:1.1rem;}#cam-container{width:150px;height:112.5px;bottom:10px;left:10px;}#intro-box{padding:20px 30px;}#intro-box h2{font-size:1.8rem;}.guide-item{font-size:1.5rem;}#start-btn{padding:8px 25px;font-size:1.2rem;}}

/* Si√™u nh·ªè (‚â§350px) */
@media (max-width: 350px) {#main-title{font-size:1.9rem;}#gesture-debug{font-size:1rem;}#cam-container{width:130px;height:97.5px;}#intro-box{padding:15px 25px;}#intro-box h2{font-size:1.6rem;}.guide-item{font-size:1.3rem;}#start-btn{padding:6px 20px;font-size:1rem;}}

        /* --- Wish Overlay --- */
        #wish-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            display: none; align-items: center; justify-content: center;
            z-index: 2000;
            transition: opacity 0.8s ease-out, visibility 0.8s;
        }
        #wish-box {
            width: 90%; max-width: 500px;
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid #D4AF37;
            border-radius: 25px;
            padding: 40px 50px;
            text-align: center;
            box-shadow: 0 0 50px rgba(212, 175, 55, 0.3);
            color: #FFD700;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #wish-box img {
            max-width: 100%; height: auto; margin-bottom: 20px; border-radius: 10px;
        }
        #wish-box p {
            font-size: 22px; margin: 0; color: #FFF8DC;
        }
        #close-wish {
            background: #D4AF37; color: #000; border: none;
            padding: 12px 40px; border-radius: 25px;
            font-family: 'Borel', serif; font-weight: bold; font-size: 16px;
            cursor: pointer; margin-top: 25px; transition: 0.3s;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.4);
        }
        #close-wish:hover { background: #FFF; box-shadow: 0 0 30px #FFF; transform: scale(1.05); }

        /* --- Wish Button --- */
        #wish-btn {
            position: absolute; bottom: 20px; right: 20px;
            background: #D4AF37; color: #000; border: none;
            padding: 10px 20px; border-radius: 20px;
            font-family: 'Borel', serif; font-weight: bold; font-size: 14px;
            cursor: pointer; transition: 0.3s;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.4);
            z-index: 10;
            display: flex; align-items: center; justify-content: center;
        }
        #wish-btn:hover { background: #FFF; box-shadow: 0 0 30px #FFF; transform: scale(1.05); }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div id="loader-text">Ch·ªù x√≠u nhen ng∆∞·ªùi ƒë·∫πp ∆∞iüòâ</div>
    </div>

    <div id="intro-overlay">
        <div id="intro-box">
            <h2>H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng d√†nh cho ng∆∞·ªùi ƒë·∫πpüòç‚ú®</h2>
            
            <div class="guide-item">
                <span class="icon">‚úåüèª</span> 
                <span>Gi∆° 2 ng√≥n tay l√† hi·ªán ch·ªØ</span>
            </div>
            <div class="guide-item">
                <span class="icon">‚òùüèª</span> 
                <span>Gi∆° 1 ng√≥n tay l√† quay v·ªÅ c√¢y th√¥ng</span>
            </div>
            <div class="guide-item">
                <span class="icon">ü§èüèª</span> 
                <span>Ch·ª•m ng√≥n tay l√† zoom xa g·∫ßn</span>
            </div>
            <div class="guide-item">
                <span class="icon">‚úäüèª</span> 
                <span>N·∫Øm b√†n tay l√† thu l·∫°i c√¢y th√¥ng</span>
            </div>
            <div class="guide-item">
                <span class="icon">üì∑</span> 
                <span>N·∫øu camera kh√¥ng d√πng ƒë∆∞·ª£c th√¨ c·∫≠u t·∫£i l·∫°i trang ho·∫∑c nh·ªù t·ªõ nheüòä</span>
            </div>
            
            <button id="start-btn" onclick="closeIntro()" >Ng∆∞·ªùi ƒë·∫πp hi·ªÉu r·ªìi th√¨ b·∫•m v√†o ƒë√¢y nhenü´∂üèªüíù</button>
        </div>
    </div>

    <div id="main-title">Lu√¥n vui v·∫ª, y√™u ƒë·ªùi nh√© c√¥ g√°i xinh ƒë·∫πp ∆°iiiüòò</div>

    <div id="cam-container">
        <video id="cam-preview" playsinline autoplay muted></video>
        <canvas id="hand-canvas"></canvas>
        <div id="cam-overlay"></div>
    </div>
    
    <div id="gesture-debug">ƒêang t√¨m camera...</div>

    <audio id="background-music" src="img_n_sound/Ch·∫≥ng gi·ªëng Gi√°ng sinh.mp3" loop style="display: none;"></audio>

    <!-- Wish Button -->
    <button id="wish-btn" onclick="showWish()">üíå</button>

    <!-- Wish Overlay -->
    <div id="wish-overlay" onclick="closeWish()">
        <div id="wish-box" onclick="event.stopPropagation();">
            <img src="https://pub-35faf01d0bac49249f374189fd3a24d9.r2.dev/images/1766489460553-fb79f69d-ece6-4aba-af24-870c148c3dc6.jpg"> <!-- Thay b·∫±ng ƒë∆∞·ªùng d·∫´n ·∫£nh th·ª±c t·∫ø -->
            <p>Ch√∫c Chi lu√¥n h·ªçc gi·ªèi, xinh ƒë·∫πp, y√™u ƒë·ªùi!!!</p>
            <p>H√£y lu√¥n vui t∆∞∆°i nh√© ng∆∞·ªùi ∆°iüòò</p>
            <button id="close-wish" onclick="closeWish()">ƒê√≥ng l·ªùi ch√∫c</button>
        </div>
    </div>

    <script>
        // H√†m t·∫Øt m√†n h√¨nh h∆∞·ªõng d·∫´n
        function closeIntro() {
            const overlay = document.getElementById('intro-overlay');
            overlay.style.opacity = '0';
            setTimeout(() => {
                overlay.style.visibility = 'hidden';
            }, 800);
            const music = document.getElementById('background-music');
            music.volume = 0.03; // Gi·∫£m √¢m l∆∞·ª£ng xu·ªëng 5%
            music.play();
            // Lazy init AI
            window.app.initAI();
        }

        // H√†m hi·ªÉn th·ªã l·ªùi ch√∫c
        function showWish() {
            const overlay = document.getElementById('wish-overlay');
            overlay.style.display = 'flex';
            overlay.style.opacity = '1';
            overlay.style.visibility = 'visible';
        }

        // H√†m ƒë√≥ng l·ªùi ch√∫c
        function closeWish() {
            const overlay = document.getElementById('wish-overlay');
            overlay.style.opacity = '0';
            setTimeout(() => {
                overlay.style.display = 'none';
                overlay.style.visibility = 'hidden';
            }, 800);
        }
    </script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from "@mediapipe/tasks-vision";

        class ChristmasGestures {
            constructor() {
                this.config = {
                    particleCount: 3000,
                    snowCount: 400,
                    frameCount: 8,       
                    colors: [0xFFD700, 0xFFE5B4, 0xDAA520, 0xFFFFE0, 0xB8860B, 0xFF0000, 0xDC143C] 
                };

                this.state = {
                    mode: 'tree', 
                    zoom: 1.0,    
                    rotationSpeed: 0.1, 
                    targetRotationSpeed: 0.1,
                    frameScale: 1.0, 
                    handDetected: false,
                };

                this.positions = { tree: [], text: [], explosion: [] };
                this.particles = [];
                this.frames = []; 
                this.dummy = new THREE.Object3D(); 

                this.lastTime = 0;
                this.lastPredictionTime = 0; 
                this.mouse = new THREE.Vector2(999, 999);
                this.morphTimeout = null; 
                
                this.holdStart = 0;      
                this.twoFingerStart = 0; 
                
                this.onResize = this.onResize.bind(this);

                this.initThree();
                this.initPostProcessing();
                this.initParticles();
                this.initFrames(); // Ch·ª©a ph·∫ßn th√™m ·∫£nh
                this.initSnow();
                // AI init moved to closeIntro

                new FontLoader().load('https://threejs.org/examples/fonts/optimer_bold.typeface.json', (font) => {
                    this.loadedFont = font;
                    this.calculatePositions(font).then(() => {
                        this.targetPositions = this.positions.tree;
                        
                        // T·∫Øt Loader, hi·ªán Intro Box
                        document.getElementById('loader').style.opacity = 0;
                        setTimeout(() => {
                            const l = document.getElementById('loader');
                            if(l) l.remove();
                        }, 1000);
                        
                        this.animate();
                    });
                });

                window.addEventListener('resize', this.onResize);
                window.addEventListener('mousemove', (e) => {
                    if (!this.state.handDetected) {
                        this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                        this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                        this.state.targetRotationSpeed = (this.mouse.x + 1) * 0.5;
                    }
                });
            }

            initThree() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000000);
                this.scene.fog = new THREE.FogExp2(0x000000, 0.015);

                this.camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 0, 90);

                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: false, powerPreference: "high-performance", preserveDrawingBuffer: true 
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                if (window.innerWidth < 768) this.renderer.setPixelRatio(1);
                else this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.outputColorSpace = THREE.SRGBColorSpace; 
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                document.body.appendChild(this.renderer.domElement);

                this.scene.add(new THREE.AmbientLight(0xffffff, 0.8)); 
                const dirLight = new THREE.DirectionalLight(0xffffff, 2.5);
                dirLight.position.set(0, 50, 50);
                this.scene.add(dirLight);

                const starGeo = new THREE.IcosahedronGeometry(1.5, 0);
                const starMat = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
                this.starMesh = new THREE.Mesh(starGeo, starMat);
                this.starMesh.position.set(0, 32, 0); 
                this.scene.add(this.starMesh);
            }

            initPostProcessing() {
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                this.bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                this.bloomPass.threshold = 0.85; 
                this.bloomPass.strength = 1.2;
                this.bloomPass.radius = 0.5;
                this.composer.addPass(this.bloomPass);
            }

            initParticles() {
                const geo = new THREE.SphereGeometry(0.12, 4, 4);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                this.instancedMesh = new THREE.InstancedMesh(geo, mat, this.config.particleCount);
                this.scene.add(this.instancedMesh);

                this.particles = [];
                const GREEN_COLOR = 0x228B22; 

                for(let i=0; i<this.config.particleCount; i++) {
                    let rawColor;
                    let isGreen = false;
                    if (Math.random() < 0.04) {
                        rawColor = GREEN_COLOR; isGreen = true;
                    } else {
                        rawColor = this.config.colors[Math.floor(Math.random()*this.config.colors.length)];
                    }
                    const color = new THREE.Color(rawColor);
                    if (!isGreen) color.offsetHSL(0, 0, Math.random()*0.4); 
                    else color.offsetHSL(0, 0, Math.random()*0.1);
                    
                    this.instancedMesh.setColorAt(i, color);
                    const pos = new THREE.Vector3((Math.random()-0.5)*200, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
                    const isBig = Math.random() < 0.1; 
                    const scale = isBig ? (2.5 + Math.random() * 2.0) : (0.5 + Math.random());

                    this.particles.push({
                        current: pos.clone(), velocity: new THREE.Vector3(),
                        originalColor: color.clone(), baseScale: scale,
                        phase: Math.random() * Math.PI * 2, speed: 0.03 + Math.random() * 0.03,
                        isGreen: isGreen
                    });
                    this.dummy.position.copy(pos); this.dummy.updateMatrix();
                    this.instancedMesh.setMatrixAt(i, this.dummy.matrix);
                }
                this.instancedMesh.instanceColor.needsUpdate = true;
            }

            // --- H√ÄM T·∫†O KHUNG ·∫¢NH (B·∫†N THAY LINK ·ªû ƒê√ÇY) ---
            initFrames() {
                // ============================================
                // üëá THAY LINK ·∫¢NH C·ª¶A B·∫†N V√ÄO D∆Ø·ªöI ƒê√ÇY üëá
                // ============================================
                const myImages = [
                    "https://user0182.na.imgto.link/public/20251223/ntc.avif",
                    "https://user0182.na.imgto.link/public/20251223/ntc1.avif",
                    "https://user0182.na.imgto.link/public/20251223/ntc2.avif",
                    "https://user0182.na.imgto.link/public/20251223/ntc3.avif"
                ];

                // ============================================

                const borderGeo = new THREE.BoxGeometry(4.2, 4.9, 0.1); 
                const borderMat = new THREE.MeshStandardMaterial({
                    color: 0xFFC125, emissive: 0xFFC125, emissiveIntensity: 0.2, roughness: 0.3, metalness: 0.8
                });
                const photoGeo = new THREE.PlaneGeometry(4, 4.7);
                const photoMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const textureLoader = new THREE.TextureLoader();
                const goldenAngle = Math.PI * (3 - Math.sqrt(5)); 

                for(let i=0; i<this.config.frameCount; i++) {
                    const group = new THREE.Group();
                    const borderMesh = new THREE.Mesh(borderGeo, borderMat.clone());
                    group.add(borderMesh);
                    const photoMesh = new THREE.Mesh(photoGeo, photoMat.clone());
                    photoMesh.position.z = 0.06;
                    
                    // L·∫•y ·∫£nh t·ª´ danh s√°ch myImages
                    const imgUrl = myImages[i % myImages.length];
                    textureLoader.load(imgUrl, (tex) => {
                        tex.colorSpace = THREE.SRGBColorSpace;
                        photoMesh.material.map = tex;
                        photoMesh.material.needsUpdate = true;
                    });

                    group.add(photoMesh);
                    this.scene.add(group);
                    
                    const y = 20 - (i / (this.config.frameCount - 1)) * 40; 
                    const theta = i * goldenAngle * 3; 
                    this.frames.push({ 
                        mesh: group, baseTheta: theta, baseY: y, baseScale: 1, currentScale: 1
                    });
                }
            }

            initSnow() {
                const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
                const ctx = cvs.getContext('2d');
                const grd = ctx.createRadialGradient(16,16,0,16,16,16);
                grd.addColorStop(0,'rgba(255,255,255,0.9)'); grd.addColorStop(1,'rgba(255,255,255,0)');
                ctx.fillStyle=grd; ctx.fillRect(0,0,32,32);
                
                const geo = new THREE.BufferGeometry();
                const pos = []; this.snowVel = [];
                for(let i=0; i<this.config.snowCount; i++){
                    pos.push((Math.random()-0.5)*300, (Math.random()-0.5)*200, (Math.random()-0.5)*100);
                    this.snowVel.push({y: 0.05 + Math.random()*0.1, x: Math.random()*100, sway: Math.random() * Math.PI});
                }
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                const mat = new THREE.PointsMaterial({ size: 1.2, map: new THREE.CanvasTexture(cvs), transparent: true, opacity: 0.7, depthWrite: false, blending: THREE.AdditiveBlending });
                this.snowSystem = new THREE.Points(geo, mat);
                this.scene.add(this.snowSystem);
            }

            async calculatePositions(font) {
                const treeArr = [];
                const h=70, maxR=25;
                for(let i=0; i<this.config.particleCount; i++) {
                    const p = i/this.config.particleCount;
                    const y = 30 - p*h;
                    const r = Math.pow(p, 0.8) * maxR; 
                    const theta = i * 2.39996;
                    const rVar = r * Math.sqrt(Math.random());
                    treeArr.push(new THREE.Vector3(Math.cos(theta)*rVar, y, Math.sin(theta)*rVar));
                }
                this.positions.tree = treeArr;
                await this.updateText("P r e t t y  g i r l !");
            }

            updateText(str) {
                return new Promise(resolve => {
                    const arr = [];
                    const config = { font: this.loadedFont, size: 8, height: 0.3, curveSegments: 4 };
                    const geo = new TextGeometry(str, config);
                    geo.center();
                    const sampler = new MeshSurfaceSampler(new THREE.Mesh(geo)).build();
                    const tmp = new THREE.Vector3();
                    for(let i=0; i<this.config.particleCount; i++) {
                        sampler.sample(tmp); arr.push(tmp.clone());
                    }
                    this.positions.text = arr;
                    resolve();
                });
            }

            async initAI() {
                try {
                    const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                    this.handLandmarker = await HandLandmarker.createFromOptions(vision, {
                        baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
                        runningMode: "VIDEO", numHands: 1
                    });
                    
                    const constraints = {
                        video: { facingMode: "user", width: { ideal: 640 }, height: { ideal: 480 } }
                    };
                    const vid = document.getElementById('cam-preview');
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    vid.srcObject = stream;
                    vid.addEventListener("loadeddata", () => this.predictWebcam());
                } catch(e) { 
                    console.error("Cam Error", e); 
                    document.getElementById('gesture-debug').innerHTML = "C·∫≠u cho ph√©p d√πng camera ƒë·ªÉ xem c√¢y th√¥ng nhe‚ò∫Ô∏è";
                }
            }

            predictWebcam() {
                const vid = document.getElementById('cam-preview');
                const now = performance.now();
                try {
                    if(this.handLandmarker && vid.currentTime !== this.lastTime && (now - this.lastPredictionTime > 60)) {
                        this.lastTime = vid.currentTime;
                        this.lastPredictionTime = now;
                        const result = this.handLandmarker.detectForVideo(vid, now);
                        this.processGestures(result, now);
                    }
                } catch (err) { }
                requestAnimationFrame(() => this.predictWebcam());
            }

            drawHandSkeleton(landmarks) {
                const canvas = document.getElementById('hand-canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 3; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                const connections = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8], [5, 9], [9, 10], [10, 11], [11, 12], [9, 13], [13, 14], [14, 15], [15, 16], [13, 17], [17, 18], [18, 19], [19, 20], [0, 17]];
                connections.forEach(([i, j]) => {
                    const p1 = landmarks[i]; const p2 = landmarks[j];
                    ctx.beginPath(); ctx.moveTo(p1.x * canvas.width, p1.y * canvas.height);
                    ctx.lineTo(p2.x * canvas.width, p2.y * canvas.height); ctx.stroke();
                });
                ctx.fillStyle = '#FF0000';
                for(let lm of landmarks) { ctx.beginPath(); ctx.arc(lm.x * canvas.width, lm.y * canvas.height, 4, 0, 2 * Math.PI); ctx.fill(); }
            }

            processGestures(result, now) {
                const statusEl = document.getElementById('gesture-debug');
                
                if (result.landmarks.length > 0) {
                    this.state.handDetected = true; 
                    const lm = result.landmarks[0]; 
                    this.drawHandSkeleton(lm);

                    let fingerCount = 0;
                    if (lm[8].y < lm[6].y) fingerCount++; 
                    if (lm[12].y < lm[10].y) fingerCount++; 
                    if (lm[16].y < lm[14].y) fingerCount++; 
                    if (lm[20].y < lm[18].y) fingerCount++; 
                    
                    const thumbDist = Math.hypot(lm[4].x - lm[0].x, lm[4].y - lm[0].y);
                    const indexDist = Math.hypot(lm[5].x - lm[0].x, lm[5].y - lm[0].y);
                    const isThumbExtended = (thumbDist > indexDist * 1.1);
                    if (isThumbExtended) fingerCount++; 

                    const pinchDist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
                    const targetScale = THREE.MathUtils.clamp(THREE.MathUtils.mapLinear(pinchDist, 0.05, 0.3, 0.5, 4.0), 0.5, 4.0);
                    this.state.frameScale += (targetScale - this.state.frameScale) * 0.1;

                    if (fingerCount === 2) {
                        if (this.state.mode !== 'text' && this.state.mode !== 'morphing') {
                            if (this.twoFingerStart === 0) this.twoFingerStart = now;
                            const elapsed = now - this.twoFingerStart;
                            if (elapsed > 3000) {
                                this.triggerMorph(true, 'text'); this.twoFingerStart = 0;
                            } else {
                                const timeLeft = Math.ceil((3000 - elapsed)/1000);
                                statusEl.innerHTML = `‚úåüèª Gi·ªØ 2 ng√≥n tay sau ${timeLeft}s ƒë·ªÉ hi·ªán ch·ªØ`;
                            }
                        } else {
                            this.twoFingerStart = 0; statusEl.innerHTML = `‚úåüèª 2 ng√≥n tay: ƒëang hi·ªán ch·ªØ`;
                        }
                        this.holdStart = 0; 
                    }
                    else if (fingerCount === 1) {
                        this.twoFingerStart = 0; 
                        if (this.state.mode !== 'tree' && this.state.mode !== 'morphing') {
                            if (this.holdStart === 0) this.holdStart = now; 
                            const elapsed = now - this.holdStart;
                            if (elapsed > 3000) { 
                                 this.triggerMorph(true, 'tree'); this.holdStart = 0; 
                            } else {
                                 const timeLeft = Math.ceil((3000 - elapsed)/1000);
                                 statusEl.innerHTML = `‚òùüèª Gi·ªØ y√™n 1 ng√≥n tay sau ${timeLeft}s ƒë·ªÉ quay v·ªÅ c√¢y th√¥ng`;
                            }
                        } else {
                            this.holdStart = 0; statusEl.innerHTML = "‚òùüèª 1 ng√≥n tay: c√¢y th√¥ng";
                        }
                    } else {
                        this.holdStart = 0; this.twoFingerStart = 0;
                        if (fingerCount === 0) {
                            this.state.zoom += (1.0 - this.state.zoom) * 0.05; statusEl.innerHTML = "‚úäüèª N·∫Øm b√†n tay: thu l·∫°i";
                        } else if (fingerCount === 5) {
                            this.state.zoom += (2.5 - this.state.zoom) * 0.05; statusEl.innerHTML = "üñêüèª 5 ng√≥n tay: zoom";
                        } else {
                            statusEl.innerHTML = `ü§èüèª Ch·ª•m ng√≥n tay: zoom ƒë·ªÅu`;
                        }
                    }
                    
                    const rotDx = lm[9].x - lm[0].x;
                    const rotDy = lm[9].y - lm[0].y;
                    const angle = Math.atan2(rotDy, rotDx);
                    this.state.targetRotationSpeed = (angle + Math.PI/2) * 2.0; 

                } else {
                    this.state.handDetected = false; 
                    this.holdStart = 0;      
                    this.twoFingerStart = 0; 
                    this.state.targetRotationSpeed = 0.05; 
                    const cvs = document.getElementById('hand-canvas');
                    cvs.getContext('2d').clearRect(0,0,cvs.width, cvs.height);
                    statusEl.innerHTML = "ƒêang t√¨m b√†n tay... (D√πng chu·ªôt ƒë·ªÉ xoay c√¢y th√¥ngüîÑÔ∏è)";
                }
            }

            triggerMorph(isBigExplosion = true, targetMode = 'tree') {
                if(this.state.mode === 'morphing') return;
                this.state.mode = 'morphing';
                
                this.particles.forEach(p => {
                    const dir = p.current.clone().normalize();
                    const force = isBigExplosion ? (1.5 + Math.random() * 1.5) : (0.1 + Math.random() * 0.1);
                    p.velocity.add(dir.multiplyScalar(force));
                });

                if (this.morphTimeout) clearTimeout(this.morphTimeout);
                this.morphTimeout = setTimeout(() => {
                    this.state.mode = targetMode;
                    if (targetMode === 'tree') {
                        this.targetPositions = this.positions.tree;
                        document.getElementById('main-title').innerText = "Lu√¥n vui v·∫ª, y√™u ƒë·ªùi nh√© c√¥ g√°i xinh ƒë·∫πp ∆°iiiüòò";
                    } else if (targetMode === 'text') {
                        this.targetPositions = this.positions.text;
                        document.getElementById('main-title').innerText = "Lu√¥n vui v·∫ª, y√™u ƒë·ªùi nh√© c√¥ g√°i xinh ƒë·∫πp ∆°iiiüòò";
                    }
                }, 2000); 
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const time = performance.now() * 0.001;

                if (this.starMesh) {
                    this.starMesh.rotation.y = time * 0.5; this.starMesh.rotation.z = time * 0.2;
                    const hue = 0.14; const saturation = 1.0; 
                    const lightness = 0.5 + Math.abs(Math.sin(time * 3)) * 0.4; 
                    this.starMesh.material.color.setHSL(hue, saturation, lightness);
                }

                const baseZ = 90;
                const targetZ = baseZ / this.state.zoom;
                this.camera.position.z += (targetZ - this.camera.position.z) * 0.1;

                this.state.rotationSpeed += (this.state.targetRotationSpeed - this.state.rotationSpeed) * 0.1;
                this.scene.rotation.y += this.state.rotationSpeed * 0.05;

                let i = 0;
                for(const p of this.particles) {
                    let target = (this.state.mode === 'morphing') ? null : (this.targetPositions[i] || p.current);
                    if (target) {
                        let finalTarget = target.clone();
                        if (this.state.mode === 'text') {
                             const waveY = Math.sin(time * 3.0 + finalTarget.x * 0.2) * 1.5;
                             const waveZ = Math.cos(time * 2.0 + finalTarget.x * 0.2) * 0.5;
                             finalTarget.y += waveY; finalTarget.z += waveZ;
                        }
                        const diff = finalTarget.sub(p.current);
                        const dist = diff.length();
                        if(dist > 0.05) {
                            diff.normalize().multiplyScalar(dist * p.speed); p.current.add(diff);
                        }
                    } else {
                        p.current.add(p.velocity); p.velocity.multiplyScalar(0.96);
                    }
                    this.dummy.position.copy(p.current);
                    let s = p.baseScale;
                    if (!p.isGreen) s *= (0.8 + Math.sin(time * 5 + p.phase) * 0.4);
                    if (this.state.mode === 'text') { s *= 1.2 + Math.sin(time * 10 + p.phase) * 0.3; }
                    this.dummy.scale.setScalar(s);
                    this.dummy.lookAt(this.camera.position);
                    this.dummy.updateMatrix();
                    this.instancedMesh.setMatrixAt(i, this.dummy.matrix);
                    i++;
                }
                this.instancedMesh.instanceMatrix.needsUpdate = true;

                const globalScale = this.state.frameScale;
                if (this.state.mode === 'tree' || this.state.mode === 'morphing') {
                    this.frames.forEach((f, idx) => {
                        const y = f.baseY;
                        let baseR = Math.pow((35 - y) / 75, 0.8) * 18 + 2; 
                        let targetScale = globalScale;
                        let targetIntensity = THREE.MathUtils.mapLinear(globalScale, 1.0, 3.0, 0.2, 2.5);
                        let pushOut = (globalScale - 1) * 8;
                        f.currentScale += (targetScale - f.currentScale) * 0.1;
                        const r = baseR + pushOut;
                        const theta = f.baseTheta + time * 0.1; 
                        
                        f.mesh.position.set(Math.cos(theta)*r, y, Math.sin(theta)*r);
                        f.mesh.lookAt(0, y, 0); f.mesh.rotateY(Math.PI); 
                        f.mesh.scale.setScalar(f.currentScale);
                        f.mesh.visible = true;
                        if (f.mesh.children[0].material) f.mesh.children[0].material.emissiveIntensity = targetIntensity;
                    });
                } else {
                    this.frames.forEach(f => f.mesh.visible = false);
                }

                if (time % 0.05 < 0.001) {
                    const snPos = this.snowSystem.geometry.attributes.position.array;
                    for(let j=0; j<this.config.snowCount; j++){
                        snPos[j*3+1] -= this.snowVel[j].y;
                        snPos[j*3] += Math.sin(time + this.snowVel[j].sway) * 0.1;
                        if(snPos[j*3+1] < -100) {
                            snPos[j*3+1] = 100; snPos[j*3] = (Math.random()-0.5)*300;
                        }
                    }
                    this.snowSystem.geometry.attributes.position.needsUpdate = true;
                }
                this.composer.render();
            }

            onResize() {
                this.camera.aspect = window.innerWidth/window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        window.app = new ChristmasGestures();
    </script>
</body>
</html>